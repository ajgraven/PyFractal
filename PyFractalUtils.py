# Problem is the focus of the mouse (probably stale event listener?) plotting of
# iterates works after updating property if you click on the plot afterwards

# TODO:
# - Beautify
# - Add way of bringing up list of keyboard and mouse shortcuts
# - Variable precision computations
# - Optimize fixed point/periodic point calculations
# - Add method for finding critical points
# - Add more of the features of FractalAsm:
#   + Additional default options
#   + Newton iteration
#   + Custom color schemes
#   + 
################################################

# Custom imports
import FractalPlot as FP
import FixedPoint as fp
# Tkinter imports
import tkinter as tk
from tkinter import messagebox
# Matplotlib imports
import matplotlib
import matplotlib.style as mplstyle
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.backend_bases import MouseButton
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,NavigationToolbar2Tk)
# Math imports
import math
import numpy as np
from numpy import arange,exp
from scipy.special import lambertw
# Misc input imports
from pynput import keyboard
import keyboard as kb
import mouse
# Misc. imports
from pylab import meshgrid,imshow,contour,clabel,colorbar,axis,title,show
import ipywidgets as widgets
from functools import partial


mplstyle.use('fast')

cmaps = ["jet","hsv","twilight_shifted","twilight",
         "spring", "summer", "autumn", "winter", "cool",
         "viridis", "plasma", "inferno", "magma",
         "cividis","flag", "prism", "ocean",
         "gist_earth","terrain", "gist_stern",
         "gnuplot","rainbow", "turbo","Greys"]

interps = ['bicubic','none', 'nearest', 'bilinear', 'spline16',
           'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',
           'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']

# [n,xrng,yrng,res,f_text,exitCond_text]
presets = {"Mandelbrot":    [35,[-2,.6],[-1.25,1.25],100000,"z**2+c","abs(z)>2"],
           "Tricorn":       [35,[-2,1.25],[-1.75,1.75],100000,"np.conjugate(z)**2+c","abs(z)>2"],
           "Sqrt Limacon":  [20,[-1.5,2.5],[-2,2],10000,"np.conjugate(z/np.sqrt(z*np.sqrt(1+1/(2*z)**2)-1/2)**3)","abs(z*np.sqrt(1+1/(2*z)**2)-1/2)<1"],
           "6-Cauliflower": [20,[-1.5,1.5],[-1.5,1.5],50000,"(np.sqrt(1. + 0.25/(-1. + 1/((1/3) + 0.5291336839893998/(4. + (3.*(-9. + np.sqrt(-24. + 81./z**6)*z**3))/z**6)**(1/3) + 0.20998684164914552*(4. + (3.*(-9. + np.sqrt(-24. + 81./z**6)*z**3))/z**6)**(1/3))))/(z*np.sqrt(1/3 + 0.5291336839893998/(4. + (3.*(-9. + np.sqrt(-24. + 81./z**6)*z**3))/z**6)**0.3333333333333333 + 0.20998684164914552*(4. + (3.*(-9. + np.sqrt(-24. + 81./z**6)*z**3))/z**6)**(1/3))))",
                                                            "abs(z*((1/3) + 2**(2/3)/(3.*(4 + (3*(-9 + (-24 + 81/z**6)**(1/2)*z**3))/z**6)**(1/3)) + (4 + (3*(-9 + (-24 + 81/z**6)**(1/2)*z**3))/z**6)**(1/3)/ (3.*2**(2/3)))**(1/2))<1"],
           "Trefoil":       [10,[-5,5],[-5,5],50000,"np.conjugate(1.8171205928321397/(np.sqrt((-1.*(2.8844991406148166 + 1.2599210498948732*(np.sqrt(-12. + 81./z**6) + 9./z**3)**(2/3)))/((np.sqrt(-12. + 81./z**6) + 9./z**3)**(1/3)*z**3))*z))",
                                                    "abs((-0.30285343213869*(2.8844991406148166 + 1.2599210498948732*(np.sqrt(-12. + 81./z**6) + 9./z**3)**(2/3))*z)/(np.sqrt(-12. + 81./z**6) + 9./z**3)**(1/3))<1"],
           "Bernoulli Lemniscate":[20,[-1.5,1.5],[-1,1],10000,"np.conjugate(z/np.sqrt(z**2-1))","abs(z**2-1)<1"],
           "Sqrt Ellipse":  [10,[-.5,.5],[-.5,.5],50000,"np.sqrt(0.5 + np.sqrt(0.25 - (2*c)/z**4))*np.sqrt(2*c + 1/((0.5 + np.sqrt(0.25 - (2*c)/z**4))**2*z**4))*z",
                                                    "abs(np.sqrt(0.5 + np.sqrt(0.25 - (2*c)/z**4))*z)<1"],
           "Exponential Droplet":       [20,[-2,15],[-6,6],60000,"np.conjugate((c**2/z)/exp(lambertw(-c**2/z)+c**2/lambertw(-c**2/z)))","abs(lambertw(-c**2/z))>abs(c)"]}
preset_names = ["Mandelbrot","Tricorn","6-Cauliflower","Trefoil","Sqrt Limacon","Bernoulli Lemniscate","Sqrt Ellipse","Exponential Droplet"]


class DynamicalPlot:
    '''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%% Attributes %%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%
    master              : tk window         : window which created this instance of self
    main_window         : tk window         : the primary window for self
    is_top              : bool              : is this the top level tk window
    is_julia            : bool              : dynamical plane (true) or parameter space (false)
    f_text              : string            : expression for the function to be iterated (the function associated to the fractal)
    exitCond_text       : string            : expression for iteration exit condition
    child_fractal_plots : DynamicalPlot arr : new instances of DynamicalPlot generated by self
    default_xrng        : [float,float]     : default plot window x-axis range
    default_yrng        : [float,float]     : default plot window y-axis range
    FractPlot           : FractalPlot       : instance of FractalPlot object for this window
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%% Methods %%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    make_controls        : c           -> None          : sets up, but doesn't place, control widgets
    setup_window         : None        -> None          : sets up figure, placing widgets and plots
    apply_chagces        : None        -> None          : applies changes to plot parameters
    make_child_plot      : c,xrng,yrng -> None          : instantiates new DynamicalPlot (Julia) with parameter c and plot window (xrng)x(yrng)
    update_from_inputs   : None        -> None          : updates self and FractPlot attributes from user input
    update_range_text    : None        -> None          : updates axis range text boxes according to FractPlot values
    set_zoom_default     : None        -> None          : resets axes ranges of FractPlot and text input boxes to values at instantiation (does not update plot)
    show_periodic_orbits : None        -> None          : gets periodic orbit period from text box, finds and plots periodic points with this period
    get_xrng_input       : None        -> [float,float] : retrieves x range from text boxes
    get_yrng_input       : None        -> [float,float] : retrieves y range from text boxes
    get_c_input          : None        -> complex       : gets value of c from text boxes (only relevant if is_julia)
    '''
    def __init__(self,master,is_top=False,is_julia=False,xrng=[-2,.5],yrng=[-1.25,1.25],res=50000,N=40,f_text="z**2+c",exitCond_text="abs(z)>2",c=.4+.6j):
        # Constructor required input
        self.master = master # master window (the window which instantiated this one)
        self.is_top = is_top # bool indicating whether this plot is the top level window
        self.is_julia = is_julia # true if we're showing the Julia set and false if the dynamical plane
        self.f_text = f_text
        self.exitCond_text = exitCond_text

        # Default values
        nits = 6
        per = 1

        # Instantiate internal attributes
        self.child_fractal_plots = []
        self.default_xrng = xrng
        self.default_yrng = yrng
        self.default_cmap = "twilight_shifted"
        self.default_interp = "bicubic"

        # Setup Tk window
        if is_top:
            self.main_window = self.master
        else:
            self.main_window = tk.Toplevel(self.master)
        self.main_window.title("Fractal Visualizer")

        # Set up plot window
        self.FractPlot = FP.FractalPlot(self.main_window,self,self.is_julia,compile(f_text, '<string>', 'eval'),
                                        compile(exitCond_text, '<string>', 'eval'),xrng,yrng,res,N,c) # fractal plot obj
        self.FractPlot.set_cmap(self.default_cmap)
        self.FractPlot.draw_plot()
        self.make_controls(c)
        self.setup_window()

                
        
    def apply_changes(self):
        self.update_from_inputs()
        self.FractPlot.update_plot()

    def add_child_plot(self,c,xrng,yrng):
        self.child_fractal_plots.append(DynamicalPlot(self.master,False,True,xrng=xrng,yrng=yrng,c=c,f_text=self.f_text,exitCond_text=self.exitCond_text))

    def update_from_inputs(self): # Gather input values and update the corresponding variables
        self.f_text        = self.input_fcn_tb.get("1.0",tk.END)
        self.exitCond_text = self.input_exit_tb.get("1.0",tk.END)
        self.FractPlot.set_xrng(        self.get_xrng_input())
        self.FractPlot.set_yrng(        self.get_yrng_input())
        self.FractPlot.set_period(      int(self.per_input_var.get()))
        self.FractPlot.set_nits(        int(self.nits_input_var.get()))
        self.FractPlot.set_res(         int(self.res_input_var.get()))
        self.FractPlot.set_N(           int(self.N_input_var.get()))
        self.FractPlot.set_cmap(        self.cmap_input_var.get())
        self.FractPlot.set_interp(      self.interp_input_var.get())
        self.FractPlot.set_f(           compile(self.f_text, '<string>', 'eval'))
        self.FractPlot.set_exitCond(    compile(self.exitCond_text, '<string>', 'eval'))
        self.update_img_file_name()
        self.update_anim_clist()
        if self.is_julia:
            self.FractPlot.set_c(self.get_c_input())

    def update_range_text(self): # Update plot range from values input by user
        xrng = self.FractPlot.get_xrng()
        yrng = self.FractPlot.get_yrng()
        self.input_xmin_tb.delete(0,tk.END)
        self.input_xmin_tb.insert(0,xrng[0])
        self.input_xmax_tb.delete(0,tk.END)
        self.input_xmax_tb.insert(0,xrng[1])
        self.input_ymin_tb.delete(0,tk.END)
        self.input_ymin_tb.insert(0,yrng[0])
        self.input_ymax_tb.delete(0,tk.END)
        self.input_ymax_tb.insert(0,yrng[1])

    def set_zoom_default(self):
        self.FractPlot.set_xrng(self.default_xrng)
        self.FractPlot.set_yrng(self.default_yrng)
        self.update_range_text()

    def show_periodic_orbits(self):
        self.update_from_inputs()
        self.FractPlot.draw_per_plot()

    def get_xrng_input(self):
        return [float(self.xrng_input_var[0].get()),float(self.xrng_input_var[1].get())]

    def get_yrng_input(self):
        return [float(self.yrng_input_var[0].get()),float(self.yrng_input_var[1].get())]

    def get_c_input(self):
        return float(self.rec_input_var.get())+float(self.imc_input_var.get())*1j

    def update_img_file_name(self):
        self.FractPlot.set_img_file_name(self.animation_fname_input_var.get())

    def update_anim_clist(self):
        try:
            t_cvals=self.input_animation_clist_tb.get("1.0",tk.END).split(",")
            self.FractPlot.set_anim_clist([complex(c.strip()) for c in t_cvals])
        except:
            rnginfo=self.input_animation_clist_tb.get("1.0",tk.END).split(";")
            c_min = complex(rnginfo[0].strip())
            c_max = complex(rnginfo[1].strip())
            revals=np.linspace(np.real(c_min),np.real(c_max),int(rnginfo[2]))
            imvals=np.linspace(np.imag(c_min),np.imag(c_max),int(rnginfo[2]))
            self.FractPlot.set_anim_clist(revals+1j*imvals)
        

    def draw_updated_cmap(self,event):
        self.FractPlot.set_cmap(self.cmap_input_var.get())
        self.FractPlot.draw_plot()

    def draw_updated_iterp(self,event):
        self.FractPlot.set_interp(self.interp_input_var.get())
        self.FractPlot.draw_plot()

    def update_nits(self,*args):
        if self.nits_input_var.get() != '':
            self.FractPlot.set_nits(int(self.nits_input_var.get()))

    def set_from_preset(self,event):
        choice = presets[event]
        self.input_N_tb.delete(0,tk.END)
        self.input_N_tb.insert(0,choice[0])
        self.FractPlot.set_xrng(choice[1])
        self.FractPlot.set_yrng(choice[2])
        self.update_range_text()
        self.input_res_tb.delete(0,tk.END)
        self.input_res_tb.insert(0,choice[3])
        self.input_fcn_tb.delete('1.0',tk.END)
        self.input_fcn_tb.insert('1.0',choice[4])
        self.input_exit_tb.delete('1.0',tk.END)
        self.input_exit_tb.insert('1.0',choice[5])
        self.default_xrng = choice[1]
        self.default_yrng = choice[2]


    #################################
    #### set up inputs and style ####
    #################################

    def make_controls(self,c): # Set up control panel
        self.control_lframe = tk.LabelFrame(self.main_window,text='Controls')
        # Plot periodic points button and period input
        self.per_lframe = tk.LabelFrame(self.control_lframe,text='Periodic Orbits')
        self.per_plot_button = tk.Button(self.per_lframe,
                                           text="find",command=self.show_periodic_orbits)
        self.per_input_var = tk.StringVar()
        self.input_per_txt_label = tk.Label(self.per_lframe,text="period=",justify='left')
        self.input_per_tb = tk.Entry(self.per_lframe,textvariable=self.per_input_var,width=4)
        self.input_per_tb.insert(0,self.FractPlot.get_period())

        # Text box for custom function input and label
        self.fcn_lframe = tk.LabelFrame(self.control_lframe,text='f(z,c)')
        self.input_fcn_tb = tk.Text(self.fcn_lframe,height=4,width=30)
        self.input_fcn_tb.insert('1.0',self.f_text)

        # Text box for custom exit condition input and label
        self.exit_lframe = tk.LabelFrame(self.control_lframe,text='Exit Condition')
        self.input_exit_tb = tk.Text(self.exit_lframe,height=3,width=30)
        self.input_exit_tb.insert('1.0',self.exitCond_text)

        # Colormap & interpolation dropdown menus
        self.cmap_interp_lframe = tk.LabelFrame(self.control_lframe,text='Color Map')
        self.cmap_input_var = tk.StringVar()
        self.interp_input_var = tk.StringVar()
        self.cmap_input_var.set(self.default_cmap)
        self.interp_input_var.set(self.default_interp)
        self.input_cmap_dd = tk.OptionMenu(self.cmap_interp_lframe,self.cmap_input_var,*cmaps,command=self.draw_updated_cmap)
        self.input_interp_dd = tk.OptionMenu(self.cmap_interp_lframe,self.interp_input_var,*interps,command=self.draw_updated_iterp)

        # Presets dropdown menus
        self.preset_lframe = tk.LabelFrame(self.control_lframe,text='Presets')
        self.preset_input_var = tk.StringVar()
        self.preset_input_var.set(preset_names[0])
        self.input_preset_dd = tk.OptionMenu(self.preset_lframe,self.preset_input_var,*preset_names,command=self.set_from_preset)

        # Labeled "animation" frame
        self.animation_lframe = tk.LabelFrame(self.control_lframe,text='animate')
        self.animation_fname_input_var = tk.StringVar()
        self.animation_fname_input_var.trace_add(['write','read'],lambda x,y,z:self.update_img_file_name()) 
        self.input_animation_fname_label = tk.Label(self.animation_lframe,text="image name",justify='left')
        self.input_animation_tb = tk.Entry(self.animation_lframe,textvariable=self.animation_fname_input_var,width=8)
        self.input_animation_tb.insert(0,"1.gif")
        self.animation_clist_input_var = tk.StringVar() 
        self.input_animation_clist_label = tk.Label(self.animation_lframe,text="c values",justify='left')
        self.input_animation_clist_tb = tk.Text(self.animation_lframe,height=4,width=30)
        self.input_animation_clist_tb.insert('1.0',"1+1j")
        self.animation_save_gif_button = tk.Button(self.animation_lframe,
                                           text="save gif",command=self.FractPlot.save_gif_local)
        self.animation_save_figure_button = tk.Button(self.animation_lframe,
                                           text="save figure",command=self.FractPlot.save_figure_local)


        # Labeled frame for misc. parameters
        self.param_lframe = tk.LabelFrame(self.control_lframe,text='Parameters')
        # Text box for setting number of iterates and label
        self.nits_input_var = tk.StringVar()
        self.input_nits_txt_label = tk.Label(self.param_lframe,text="# iterates=",justify='left')
        self.input_nits_tb = tk.Entry(self.param_lframe,textvariable=self.nits_input_var,width=8)
        self.input_nits_tb.insert(0,self.FractPlot.get_nits())
        self.nits_input_var.trace("w",self.update_nits)
        # Text box for setting resolution and label
        self.res_input_var = tk.StringVar()
        self.input_res_txt_label = tk.Label(self.param_lframe,text="# pixels=",justify='left')
        self.input_res_tb = tk.Entry(self.param_lframe,textvariable=self.res_input_var,width=8)
        self.input_res_tb.insert(0,self.FractPlot.get_res())
        # Text box for setting # of iterations per point
        self.N_input_var = tk.StringVar()
        self.input_N_txt_label = tk.Label(self.param_lframe,text="Max # of\nIterations=",justify='left')
        self.input_N_tb = tk.Entry(self.param_lframe,textvariable=self.N_input_var,width=8)
        self.input_N_tb.insert(0,self.FractPlot.get_N())

        

        # Text boxes and labels for setting axis ranges
        self.axis_range_lframe = tk.LabelFrame(self.control_lframe,text='axis ranges')
        self.default_zoom_button = tk.Button(self.axis_range_lframe,
                                           text="reset",command=self.set_zoom_default)
        self.xrng_input_var = [tk.StringVar(),tk.StringVar()]
        self.yrng_input_var = [tk.StringVar(),tk.StringVar()]
        self.input_xmin_tb = tk.Entry(self.axis_range_lframe,textvariable=self.xrng_input_var[0],width=6,justify='center')
        self.input_xrng_txt_label = tk.Label(self.axis_range_lframe,text="<re<",width=4,justify='center')
        self.input_xmax_tb = tk.Entry(self.axis_range_lframe,textvariable=self.xrng_input_var[1],width=6,justify='center')
        self.input_ymin_tb = tk.Entry(self.axis_range_lframe,textvariable=self.yrng_input_var[0],width=6,justify='center')
        self.input_yrng_txt_label = tk.Label(self.axis_range_lframe,text="<im<",width=4,justify='center')
        self.input_ymax_tb = tk.Entry(self.axis_range_lframe,textvariable=self.yrng_input_var[1],width=6,justify='center')
        self.update_range_text()

        # Text box for setting c
        if self.is_julia:
            self.c_lframe = tk.LabelFrame(self.control_lframe,text='c')
            self.rec_input_var = tk.StringVar()
            self.imc_input_var = tk.StringVar()
            self.input_rec_txt_label = tk.Label(self.c_lframe,text="re",justify='left')
            self.input_imc_txt_label = tk.Label(self.c_lframe,text="im",justify='left')
            self.input_rec_tb = tk.Entry(self.c_lframe,textvariable=self.rec_input_var,width=20)
            self.input_imc_tb = tk.Entry(self.c_lframe,textvariable=self.imc_input_var,width=20)
            self.input_rec_tb.insert(0,np.real(c))
            self.input_imc_tb.insert(0,np.imag(c))


        # Apply changes button
        self.update_plot_button = tk.Button(self.control_lframe,
                                           text="apply changes",command=self.apply_changes)
        
        # Clear plot button
        self.clear_plot_button = tk.Button(self.control_lframe,
                                           text="clear plot",command=self.FractPlot.clear_plot)

            
    def setup_window(self):
        # Set up configuration of window
        self.main_window.grid_rowconfigure(0, weight=1,minsize=500)
        self.main_window.grid_columnconfigure(0, weight=0,minsize=300)
        self.main_window.grid_columnconfigure(1, weight=1,minsize=500)

        
        self.FractPlot.get_widget().grid(       row=0,column=1,rowspan=1,columnspan=1,sticky='NSEW')

        self.control_lframe.grid(               row=0,column=0,rowspan=1,columnspan=1,padx=10,pady=0,sticky='NSEW')
        
        self.update_plot_button.grid(           row=3,column=1,rowspan=1,columnspan=1)
        self.clear_plot_button.grid(            row=4,column=1,rowspan=1,columnspan=1)
        
        self.fcn_lframe.grid(                   row=0,column=0,rowspan=1,columnspan=2,padx=10,pady=2,sticky='NSEW')
        self.input_fcn_tb.grid(                 row=0,column=0,rowspan=1,columnspan=1,sticky='NSEW')
        
        self.exit_lframe.grid(                  row=1,column=0,rowspan=1,columnspan=2,padx=10,pady=2,sticky='NSEW')
        self.input_exit_tb.grid(                row=1,column=0,rowspan=1,columnspan=1,sticky='NSEW')

        self.cmap_interp_lframe.grid(           row=5,column=0,rowspan=1,columnspan=2,sticky="NSEW")
        self.input_cmap_dd.grid(                row=0,column=0,rowspan=1,columnspan=1)
        self.input_interp_dd.grid(              row=0,column=1,rowspan=1,columnspan=1)

        self.animation_lframe.grid(               row=7,column=0,rowspan=2,columnspan=3)
        self.input_animation_fname_label.grid(    row=0,column=0,rowspan=1,columnspan=1)
        self.input_animation_tb.grid(             row=0,column=1,rowspan=1,columnspan=1)
        self.input_animation_clist_tb.grid(       row=1,column=0,rowspan=1,columnspan=4)
        self.animation_save_gif_button.grid(      row=0,column=2,rowspan=1,columnspan=1)
        self.animation_save_figure_button.grid(   row=0,column=3,rowspan=1,columnspan=1)

        if not self.is_julia:
            self.preset_lframe.grid(            row=6,column=1,rowspan=1,columnspan=2,sticky="NSEW")
            self.input_preset_dd.grid(          row=0,column=0,rowspan=1,columnspan=1)

        self.param_lframe.grid(                 row=2,column=0,rowspan=1,columnspan=1)
        self.input_nits_txt_label.grid(         row=0,column=0,rowspan=1,columnspan=1)
        self.input_nits_tb.grid(                row=0,column=1,rowspan=1,columnspan=1)
        self.input_res_txt_label.grid(          row=1,column=0,rowspan=1,columnspan=1)
        self.input_res_tb.grid(                 row=1,column=1,rowspan=1,columnspan=1)
        self.input_N_txt_label.grid(            row=2,column=0,rowspan=1,columnspan=1)
        self.input_N_tb.grid(                   row=2,column=1,rowspan=1,columnspan=1)

        self.per_lframe.grid(                   row=3,column=0,rowspan=2,columnspan=1)
        self.input_per_txt_label.grid(          row=0,column=0,rowspan=1,columnspan=1)
        self.input_per_tb.grid(                 row=0,column=1,rowspan=1,columnspan=1)
        self.per_plot_button.grid(              row=0,column=2,rowspan=1,columnspan=3,padx=5,pady=5)

        self.axis_range_lframe.grid(            row=2,column=1,rowspan=1,columnspan=1)
        self.default_zoom_button.grid(          row=2,column=0,rowspan=1,columnspan=3,padx=5,pady=2)
        self.input_xmin_tb.grid(                row=0,column=0,rowspan=1,columnspan=1,padx=0,pady=2)
        self.input_xrng_txt_label.grid(         row=0,column=1,rowspan=1,columnspan=1,padx=0,pady=2)
        self.input_xmax_tb.grid(                row=0,column=2,rowspan=1,columnspan=1,padx=0,pady=2)
        self.input_ymin_tb.grid(                row=1,column=0,rowspan=1,columnspan=1,padx=0,pady=2)
        self.input_yrng_txt_label.grid(         row=1,column=1,rowspan=1,columnspan=1,padx=0,pady=2)
        self.input_ymax_tb.grid(                row=1,column=2,rowspan=1,columnspan=1,padx=0,pady=2)

        if self.is_julia:
            self.c_lframe.grid(                 row=6,column=1,rowspan=1,columnspan=2,sticky="NSEW")
            self.input_rec_txt_label.grid(      row=0,column=0,rowspan=1,columnspan=1)
            self.input_imc_txt_label.grid(      row=1,column=0,rowspan=1,columnspan=1)
            self.input_rec_tb.grid(             row=0,column=1,rowspan=1,columnspan=1)
            self.input_imc_tb.grid(             row=1,column=1,rowspan=1,columnspan=1)










